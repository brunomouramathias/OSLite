# Reflexão: Como records/structs e enums impactam o processo de desenvolvimento

O uso de **records** e **record structs** para Value Objects trouxe clareza e segurança ao código. A semântica de valor é fundamental para objetos como `Money` e `Email`: não faz sentido que duas instâncias com o mesmo valor sejam consideradas diferentes. A imutabilidade automática dos records elimina uma classe inteira de bugs relacionados a mutações indesejadas. Além disso, a igualdade estrutural facilita enormemente os testes, pois posso comparar objetos diretamente sem implementar `Equals()` manualmente. Por exemplo, nos testes posso escrever `Assert.Equal(new Money(100), item.PrecoUnitario)` e isso funciona perfeitamente porque `Money` é um record struct com igualdade por valor.

Os **enums** foram essenciais para tornar as regras de negócio explícitas. Ao usar `StatusOS` em vez de strings, as transições de estado ficaram verificáveis em tempo de compilação, e o código se tornou mais legível: é muito mais claro ler `if (Status == StatusOS.Concluida)` do que `if (status == "CONCLUIDA")`. Isso também facilitou a implementação das validações de transição, pois o compilador garante que todos os casos sejam tratados. Durante o desenvolvimento, ao adicionar novos estados, o compilador me avisaria de todos os lugares que precisam ser atualizados.

A abordagem **fail-fast** com invariantes protegidos foi crucial no TDD. Cada teste de falha tinha um objetivo claro: verificar que uma regra específica estava sendo protegida. Isso reduziu ambiguidades e tornou o código mais previsível. Por exemplo, saber que `Money` sempre será >= 0 permite que o resto do código assuma essa garantia sem verificações redundantes. O teste `Money_nao_aceita_negativo()` garante que essa invariante nunca será violada, e isso me dá confiança para usar `Money` em qualquer lugar sem medo.

A **navegabilidade bidirecional** entre `Cliente` e `OrdemDeServico` exigiu atenção especial ao sincronismo. Centralizar o vínculo no método `AdicionarOrdem()` garantiu que ambos os lados permanecessem consistentes. O uso de coleções somente leitura (`IReadOnlyCollection`) evitou que código externo quebrasse as invariantes, e o método `DefinirCliente()` internal manteve o encapsulamento. Esse cuidado preveniu estados inválidos onde, por exemplo, uma ordem "achasse" que pertence a um cliente, mas esse cliente não tivesse a ordem em sua lista. Os testes `Cliente_adiciona_ordem_sincroniza_cliente_na_ordem()` e `OS_trocar_de_cliente_atualiza_colecoes_dos_clientes()` cobrem exatamente esses cenários críticos.

Em resumo, a escolha correta entre **classes** (identidade), **records/structs** (valor) e **enums** (conjuntos fixos) tornou o código mais expressivo, testável e seguro, reduzindo significativamente a chance de bugs e facilitando a manutenção futura.

